### **Graph Theory and Combinatorics**

1. **Basic Graph Theory**: Prove that every connected graph with \( n \) vertices and \( n-1 \) edges is a tree.

2. **Eulerian Path**: Given a graph, determine if it has an Eulerian path and/or circuit.

3. **Graph Coloring**: Show that the chromatic number of a bipartite graph is 2.

4. **Planar Graphs**: Prove that a graph is planar if and only if it does not contain a subgraph that is a subdivision of \( K_5 \) or \( K_{3,3} \).

5. **Ramsey Theory**: Use Ramsey’s theorem to find the minimum number of vertices needed to ensure a complete subgraph of a specific size in a given graph.

6. **Combinatorial Optimization**: Apply Kruskal’s algorithm to find the minimum spanning tree of a given weighted graph.

7. **Network Flows**: Implement the Ford-Fulkerson algorithm to compute the maximum flow in a given flow network.

8. **Graph Isomorphism**: Determine if two given graphs are isomorphic by constructing their adjacency matrices and comparing.

9. **Matchings**: Use the Hungarian algorithm to find the maximum matching in a bipartite graph.

10. **Expander Graphs**: Prove that a given family of graphs is an expander family using spectral graph theory.

### **Probability Theory and Random Processes**

11. **Law of Total Probability**: Given a set of events, use the law of total probability to find the probability of an event.

12. **Bayes’ Theorem**: Apply Bayes’ theorem to update the probability of a hypothesis given new evidence.

13. **Markov Chains**: Analyze the steady-state distribution of a given Markov chain.

14. **Random Walks**: Compute the expected number of steps for a random walk on a 1D lattice to return to the origin.

15. **Chernoff Bounds**: Use Chernoff bounds to bound the probability of deviation in a sum of independent random variables.

16. **Poisson Processes**: Apply the properties of Poisson processes to model the number of arrivals in a given time period.

17. **Concentration Inequalities**: Use the Chernoff bound to analyze the performance of a randomized algorithm.

18. **Expectation and Variance**: Compute the expectation and variance of a given discrete random variable.

19. **Central Limit Theorem**: Apply the Central Limit Theorem to approximate the distribution of the sample mean.

20. **Monte Carlo Simulations**: Implement a Monte Carlo simulation to estimate the value of π.

### **Linear Algebra and Computational Applications**

21. **Matrix Multiplication**: Compute the product of two matrices using standard matrix multiplication.

22. **Eigenvalues and Eigenvectors**: Find the eigenvalues and eigenvectors of a given matrix.

23. **SVD**: Perform Singular Value Decomposition (SVD) on a matrix and use it for dimensionality reduction.

24. **LU Decomposition**: Decompose a matrix into its LU form and use it to solve a system of linear equations.

25. **QR Decomposition**: Use QR decomposition to solve a least-squares problem.

26. **Principal Component Analysis (PCA)**: Apply PCA to a dataset and interpret the principal components.

27. **Matrix Norms**: Compute and compare different matrix norms (Frobenius norm, spectral norm) for a given matrix.

28. **Linear Transformations**: Show how a linear transformation maps vectors from one space to another using matrix representations.

29. **Least Squares Approximation**: Implement the least squares approximation method to fit a line to a set of data points.

30. **Tensor Operations**: Perform basic tensor operations and explain their applications in machine learning.

### **Modular Arithmetic and Number Theory**

31. **Modular Inverses**: Compute the modular inverse of a given integer modulo another integer using the Extended Euclidean Algorithm.

32. **Prime Testing**: Implement and compare different algorithms for primality testing (e.g., trial division, Miller-Rabin).

33. **RSA Encryption**: Encrypt and decrypt a message using the RSA algorithm with given public and private keys.

34. **Chinese Remainder Theorem**: Solve a system of congruences using the Chinese Remainder Theorem.

35. **Elliptic Curves**: Apply elliptic curve arithmetic to solve problems in cryptography.

36. **Fermat’s Little Theorem**: Use Fermat’s Little Theorem to find modular exponentiation efficiently.

37. **Euler’s Totient Function**: Compute Euler’s totient function for a given integer and use it in cryptographic applications.

38. **Modular Exponentiation**: Implement modular exponentiation to efficiently compute large powers modulo a number.

39. **Error-Correcting Codes**: Encode and decode messages using Hamming codes.

40. **Randomized Algorithms**: Analyze the performance of a randomized algorithm and its probabilistic guarantees.

### **Applications in Cryptography and Error-Correcting Codes**

41. **Cryptographic Hash Functions**: Implement and analyze a simple cryptographic hash function (e.g., SHA-256).

42. **Digital Signatures**: Verify a digital signature using a given public key and signature.

43. **Public-Key Cryptosystems**: Demonstrate encryption and decryption using a public-key cryptosystem (e.g., RSA).

44. **Elliptic Curve Cryptography**: Implement elliptic curve cryptographic operations and explain their security benefits.

45. **Error Detection**: Apply cyclic redundancy checks (CRC) to detect errors in data transmission.

46. **Reed-Solomon Codes**: Encode and decode messages using Reed-Solomon error-correcting codes.

47. **Key Exchange Protocols**: Implement and analyze a key exchange protocol (e.g., Diffie-Hellman).

48. **Zero-Knowledge Proofs**: Implement a simple zero-knowledge proof protocol and explain its use cases.

49. **Secure Communication**: Simulate a secure communication channel using encryption and decryption algorithms.

50. **Data Integrity**: Verify the integrity of data using checksums and hash functions.
