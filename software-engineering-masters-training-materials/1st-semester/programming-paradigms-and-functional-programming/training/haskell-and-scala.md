### **Haskell Exercises**

#### **Beginner (1-25)**

1. **Factorial Calculation:**
   - Implement a function to calculate the factorial of a number.

2. **Fibonacci Sequence:**
   - Write a function to generate the nth Fibonacci number.

3. **Palindrome Checker:**
   - Create a function to check if a given string is a palindrome.

4. **Sum of Squares:**
   - Implement a function to compute the sum of squares of a list of integers.

5. **List Reversal:**
   - Write a function to reverse a list without using built-in functions.

6. **Filter Even Numbers:**
   - Implement a function to filter out even numbers from a list.

7. **Merge Sort:**
   - Create an implementation of the merge sort algorithm.

8. **Matrix Multiplication:**
   - Implement matrix multiplication for 2x2 matrices.

9. **Implement `Maybe` Monad:**
   - Define a simple version of the `Maybe` monad and implement basic operations.

10. **File I/O:**
    - Write a function to count the number of lines in a file.

11. **Parse a CSV File:**
    - Implement a function to parse a CSV file into a list of lists of strings.

12. **Generate Primes:**
    - Write a function to generate all prime numbers up to a given number using the Sieve of Eratosthenes.

13. **Create a Binary Tree:**
    - Implement a simple binary tree and provide functions for insertion and traversal.

14. **Convert to Roman Numerals:**
    - Implement a function that converts an integer to a Roman numeral.

15. **Concurrent Programming:**
    - Write a program using `forkIO` to print "Hello" and "World" concurrently.

16. **Custom List Monad:**
    - Create a custom monad based on lists and demonstrate its use.

17. **Implement `Applicative`:**
    - Implement the `Applicative` type class for a simple custom type.

18. **Parse JSON Data:**
    - Use a JSON library to parse JSON data and extract specific fields.

19. **Software Transactional Memory:**
    - Implement a counter using STM (Software Transactional Memory) for safe concurrent updates.

20. **Property-Based Testing:**
    - Write property-based tests for a function using the `QuickCheck` library.

21. **Count Vowels:**
    - Create a function that counts the number of vowels in a string.

22. **Find Maximum:**
    - Write a function to find the maximum value in a list.

23. **Generate Combinations:**
    - Implement a function to generate all combinations of a list.

24. **Count Elements:**
    - Create a function that counts occurrences of each element in a list.

25. **Flatten a List:**
    - Implement a function to flatten a list of lists.

#### **Intermediate (26-50)**

26. **Binary Search:**
    - Implement a binary search algorithm.

27. **Balanced Parentheses:**
    - Write a function to check if parentheses in a string are balanced.

28. **Unique Elements:**
    - Implement a function to remove duplicate elements from a list.

29. **Zip Lists:**
    - Create a function to zip two lists into a list of tuples.

30. **Longest Common Prefix:**
    - Write a function that finds the longest common prefix in a list of strings.

31. **Nth Largest Element:**
    - Implement a function to find the nth largest element in a list.

32. **Anagram Checker:**
    - Write a function to check if two strings are anagrams.

33. **Group Anagrams:**
    - Implement a function to group anagrams from a list of strings.

34. **Count Words:**
    - Create a function to count the number of words in a string.

35. **Flatten and Remove Duplicates:**
    - Write a function to flatten a nested list and remove duplicates.

36. **Transpose a Matrix:**
    - Implement a function to transpose a given matrix.

37. **Find the Mode:**
    - Write a function to find the mode of a list.

38. **Implement `Functor`:**
    - Define and implement the `Functor` type class for a custom type.

39. **Basic HTTP Client:**
    - Use a library to implement a simple HTTP client that fetches data from a URL.

40. **Simple Event Loop:**
    - Create a simple event loop that processes events from a queue.

41. **Implement `Foldable`:**
    - Implement the `Foldable` type class for a custom data type.

42. **Memoization:**
    - Write a memoization function to optimize recursive computations.

43. **Implement `Foldl` and `Foldr`:**
    - Define your versions of `foldl` and `foldr`.

44. **Create a State Monad:**
    - Implement a simple state monad and demonstrate its use.

45. **Count Characters:**
    - Write a function that counts the occurrences of each character in a string.

46. **Implement `Either`:**
    - Create a simple version of the `Either` type and demonstrate its use.

47. **Text Justification:**
    - Implement a function to justify text to a specific width.

48. **Sort by Frequency:**
    - Write a function to sort a list of elements by their frequency of occurrence.

49. **Rotate a List:**
    - Implement a function that rotates a list by a given number of places.

50. **Implement a Simple Calculator:**
    - Create a basic calculator that evaluates simple arithmetic expressions.

#### **Advanced (51-75)**

51. **Quicksort Algorithm:**
    - Implement the quicksort algorithm.

52. **Implement `MonadPlus`:**
    - Define and implement the `MonadPlus` type class.

53. **Implement a Simple HTTP Server:**
    - Create a basic HTTP server that handles requests.

54. **Create a Simple Game Loop:**
    - Implement a simple game loop that updates and renders game state.

55. **Pathfinding Algorithm:**
    - Implement A* or Dijkstra's algorithm for pathfinding.

56. **Type-Level Programming:**
    - Experiment with type-level programming using GHC extensions.

57. **Implement a DSL:**
    - Create a simple domain-specific language (DSL) for a specific problem domain.

58. **Build a Simple REPL:**
    - Implement a Read-Eval-Print Loop (REPL) for a mini-language.

59. **Implement `MonadReader`:**
    - Define and implement the `MonadReader` type class.

60. **Create a Simple ORM:**
    - Implement a simple Object-Relational Mapping (ORM) system.

61. **Tic-Tac-Toe Game:**
    - Build a console-based Tic-Tac-Toe game.

62. **Chat Application:**
    - Create a simple chat application using sockets.

63. **File Compression:**
    - Implement a basic file compression algorithm.

64. **Simple Database:**
    - Create a simple in-memory database with basic CRUD operations.

65. **Natural Language Processing:**
    - Implement basic NLP tasks like tokenization or stemming.

66. **Blockchain Simulation:**
    - Simulate a basic blockchain structure.

67. **Build a Web Scraper:**
    - Write a web scraper that extracts specific data from a webpage.

68. **Implement a Simple Task Queue:**
    - Create a simple task queue with worker threads.

69. **Unit Testing:**
    - Write unit tests for existing functions using a testing library.

70. **Implement a State Machine:**
    - Create a finite state machine for a simple use case.

71. **Create a Scheduler:**
    - Implement a task scheduler that executes tasks at specified intervals.

72. **Event Sourcing:**
    - Build a simple event-sourced application.

73. **LSTM Implementation:**
    - Implement a basic Long Short-Term Memory (LSTM) neural network from scratch.

74. **Design Patterns:**
    - Implement common design patterns (e.g., Singleton, Factory) in Haskell.

75. **Code Generator:**
    - Write a code generator that generates Haskell code based on input specifications.

---

### **Scala Exercises**

#### **Beginner (1-25)**

1. **Factorial Calculation:**
   - Implement a recursive function to calculate the factorial of a number.

2. **Fibonacci Sequence:**
   - Write a function to generate the nth Fibonacci number.

3. **Palindrome Checker:**
   - Create a function to check if a given string is a palindrome.

4. **Sum of Squares:**
   - Implement a function to compute the sum of squares of a list of integers.

5. **List Reversal:**
   - Write a function to reverse a list without using built-in functions.

6. **Filter Even Numbers:**
   - Implement a function to filter out even numbers from a list.

7. **Merge Sort:**
   - Create an implementation of the merge sort algorithm.

8. **Matrix Multiplication:**
   - Implement matrix multiplication for 2x2 matrices.

9. **Define a Trait and Implement:**
   - Define a trait `Shape` with methods for area and perimeter. Implement this trait for `Circle` and `Rectangle`.

10. **File I/O:**
    - Write a function to count the number of lines in a file.

11. **Parse JSON Data:**
    - Use a JSON library (e.g., `play-json` or `cir

ce`) to parse JSON data and extract specific fields.

12. **Generate Primes:**
    - Write a function to generate all prime numbers up to a given number using the Sieve of Eratosthenes.

13. **Custom Collection Class:**
    - Implement a custom collection class that behaves like a stack with `push`, `pop`, and `peek` methods.

14. **Convert to Roman Numerals:**
    - Implement a function that converts an integer to a Roman numeral.

15. **Concurrency with Futures:**
    - Use Scalaâ€™s `Future` to perform concurrent computations and combine results.

16. **Pattern Matching:**
    - Write a function that uses pattern matching to decode a simple algebraic data type.

17. **Create an Actor System:**
    - Use Akka to create a basic actor system with actors that send messages to each other.

18. **Implement a Monad:**
    - Define and implement a custom monad in Scala, demonstrating basic monadic operations.

19. **Software Transactional Memory:**
    - Use `scala.concurrent.stm` to manage a shared counter with concurrent updates.

20. **Property-Based Testing:**
    - Write property-based tests using a library like `ScalaCheck` to test functions and properties.

21. **Count Vowels:**
    - Create a function that counts the number of vowels in a string.

22. **Find Maximum:**
    - Write a function to find the maximum value in a list.

23. **Generate Combinations:**
    - Implement a function to generate all combinations of a list.

24. **Count Words:**
    - Create a function to count the number of words in a string.

25. **Flatten a List:**
    - Implement a function to flatten a list of lists.

#### **Intermediate (26-50)**

26. **Binary Search:**
    - Implement a binary search algorithm.

27. **Balanced Parentheses:**
    - Write a function to check if parentheses in a string are balanced.

28. **Unique Elements:**
    - Implement a function to remove duplicate elements from a list.

29. **Zip Lists:**
    - Create a function to zip two lists into a list of tuples.

30. **Longest Common Prefix:**
    - Write a function that finds the longest common prefix in a list of strings.

31. **Nth Largest Element:**
    - Implement a function to find the nth largest element in a list.

32. **Anagram Checker:**
    - Write a function to check if two strings are anagrams.

33. **Group Anagrams:**
    - Implement a function to group anagrams from a list of strings.

34. **Count Characters:**
    - Write a function that counts the occurrences of each character in a string.

35. **Transpose a Matrix:**
    - Implement a function to transpose a given matrix.

36. **Find the Mode:**
    - Write a function to find the mode of a list.

37. **Sort by Frequency:**
    - Write a function to sort a list of elements by their frequency of occurrence.

38. **Implement a Simple HTTP Client:**
    - Use a library to implement a simple HTTP client that fetches data from a URL.

39. **Basic HTTP Server:**
    - Create a basic HTTP server that handles requests.

40. **Basic Logging Framework:**
    - Implement a simple logging framework that writes log messages to a file.

41. **Event Loop:**
    - Create a simple event loop that processes events from a queue.

42. **Implement `Functor`:**
    - Define and implement the `Functor` type class for a custom type.

43. **Memoization:**
    - Write a memoization function to optimize recursive computations.

44. **Create a State Monad:**
    - Implement a simple state monad and demonstrate its use.

45. **Implement a Simple DSL:**
    - Create a simple domain-specific language (DSL) for a specific problem domain.

46. **Tic-Tac-Toe Game:**
    - Build a console-based Tic-Tac-Toe game.

47. **File Compression:**
    - Implement a basic file compression algorithm.

48. **Unit Testing:**
    - Write unit tests for existing functions using a testing library.

49. **Create a Custom Exception:**
    - Implement a custom exception class and demonstrate its use.

50. **Basic CRUD Application:**
    - Build a simple console-based CRUD application.

#### **Advanced (51-75)**

51. **Quicksort Algorithm:**
    - Implement the quicksort algorithm.

52. **Implement `MonadPlus`:**
    - Define and implement the `MonadPlus` type class.

53. **Chat Application:**
    - Create a simple chat application using sockets.

54. **Pathfinding Algorithm:**
    - Implement A* or Dijkstra's algorithm for pathfinding.

55. **Type-Level Programming:**
    - Experiment with type-level programming using Scala's advanced features.

56. **Implement a Simple Task Queue:**
    - Create a simple task queue with worker threads.

57. **Build a Web Scraper:**
    - Write a web scraper that extracts specific data from a webpage.

58. **Natural Language Processing:**
    - Implement basic NLP tasks like tokenization or stemming.

59. **Implement a State Machine:**
    - Create a finite state machine for a simple use case.

60. **Simple Event Sourcing:**
    - Build a simple event-sourced application.

61. **Implement a Simple ORM:**
    - Create a simple Object-Relational Mapping (ORM) system.

62. **Blockchain Simulation:**
    - Simulate a basic blockchain structure.

63. **LSTM Implementation:**
    - Implement a basic Long Short-Term Memory (LSTM) neural network from scratch.

64. **Create a Simple Game Loop:**
    - Implement a simple game loop that updates and renders game state.

65. **Design Patterns:**
    - Implement common design patterns (e.g., Singleton, Factory) in Scala.

66. **Custom Data Structure:**
    - Implement a custom data structure (e.g., a trie or a graph).

67. **Build a Simple API:**
    - Create a RESTful API using a web framework.

68. **Basic Chatbot:**
    - Implement a simple rule-based chatbot.

69. **Unit Testing:**
    - Write unit tests for existing functions using a testing library.

70. **Implement Reactive Programming:**
    - Use a reactive programming library to build a simple application.

71. **Create a Scheduler:**
    - Implement a task scheduler that executes tasks at specified intervals.

72. **Implement a Search Engine:**
    - Create a basic search engine that indexes and searches text documents.

73. **File Encryption:**
    - Implement a basic file encryption/decryption algorithm.

74. **Implement Graph Algorithms:**
    - Write functions to implement common graph algorithms (e.g., BFS, DFS).

75. **Build a Simple E-commerce Application:**
    - Create a basic e-commerce application with product listings and a shopping cart.

---

### **Example Implementations**

#### **Haskell Example: List Reversal**

```haskell
reverseList :: [a] -> [a]
reverseList = foldl (flip (:)) []
```

#### **Scala Example: List Reversal**

```scala
def reverseList[A](list: List[A]): List[A] = list.foldLeft(List.empty[A])((acc, elem) => elem :: acc)
```

#### **Haskell Example: Matrix Multiplication**

```haskell
type Matrix = [[Int]]

multiplyMatrices :: Matrix -> Matrix -> Matrix
multiplyMatrices a b = [[ sum $ zipWith (*) ar bc | bc <- transpose b ] | ar <- a]
```

#### **Scala Example: Matrix Multiplication**

```scala
def multiplyMatrices(a: Array[Array[Int]], b: Array[Array[Int]]): Array[Array[Int]] = {
  val rowsA = a.length
  val colsA = a(0).length
  val colsB = b(0).length
  val c = Array.ofDim[Int](rowsA, colsB)
  
  for (i <- 0 until rowsA; j <- 0 until colsB) {
    c(i)(j) = (0 until colsA).map(k => a(i)(k) * b(k)(j)).sum
  }
  
  c
}
```
