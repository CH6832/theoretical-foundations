\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}

\title{Lecture Notes on Stochastic Processes and Numerical Methods}
\author{}
\date{}

\begin{document}

\maketitle
\tableofcontents
\newpage

\part{Stochastic Processes}
\section{Random Numbers}
\subsection{Definition of Random Numbers}
Random numbers are sequences of numbers that lack any predictable pattern. In computational simulations, random numbers are crucial for stochastic modeling, Monte Carlo methods, and simulations involving randomness.

\subsection{Congruential RNG (Multiplicative)}
The congruential method is a simple and widely used random number generator (RNG). The multiplicative congruential method generates a sequence of random numbers \( X_n \) using the recursive relation:
\[
X_{n+1} = (a \cdot X_n + c) \mod m
\]
where \( a \) is the multiplier, \( c \) is the increment, \( m \) is the modulus, and \( X_0 \) is the seed. The choice of parameters \( a \), \( c \), and \( m \) is crucial for the quality of the RNG.

\subsection{Lagged Fibonacci RNG (Additive)}
The Lagged Fibonacci RNG is an advanced RNG that uses a sequence of lagged terms. The general formula is:
\[
X_n = (X_{n-j} \circ X_{n-k}) \mod m
\]
where \( j \) and \( k \) are lags, and \( \circ \) represents an operation such as addition, subtraction, or multiplication. This RNG can produce a longer period and better statistical properties than simpler methods.

\subsection{How Good is a RNG?}
The quality of an RNG is assessed by its period, uniformity, and independence. The period is the length before the sequence repeats. A good RNG should also pass statistical tests for uniformity and independence, such as the chi-square test, Kolmogorov-Smirnov test, and autocorrelation test.

\subsection{Non-Uniform Distributions}
Many applications require random numbers from non-uniform distributions, such as Gaussian or exponential distributions. Non-uniform random numbers can be generated by transforming uniform random numbers using methods like the inverse transform, Box-Muller, or acceptance-rejection methods.

\section{Percolation}
\subsection{The Sol-Gel Transition}
Percolation theory studies the behavior of connected clusters in a random graph. The sol-gel transition refers to the process where a system transitions from a liquid-like state (sol) to a solid-like state (gel) as clusters percolate through the system.

\subsection{The Percolation Model}
The percolation model is a mathematical model used to study the formation of connected clusters in a lattice. In a lattice of sites, each site is occupied with probability \( p \). Percolation occurs when a cluster spans from one side of the lattice to the opposite side, which happens at a critical probability \( p_c \).

\section{Fractals}
\subsection{Self-Similarity}
A fractal is a complex geometric shape that exhibits self-similarity, meaning that parts of the fractal are similar to the whole. Mathematically, a self-similar object satisfies:
\[
f(x) = \lambda f(\lambda x)
\]
for some scaling factor \( \lambda \).

\subsection{Fractal Dimension: Mathematical Definition}
The fractal dimension \( D \) quantifies the complexity of a fractal by describing how the detail in a pattern changes with the scale at which it is measured. The fractal dimension can be calculated using:
\[
D = \lim_{\epsilon \to 0} \frac{\log N(\epsilon)}{\log \frac{1}{\epsilon}}
\]
where \( N(\epsilon) \) is the number of self-similar pieces of size \( \epsilon \).

\subsection{The Box Counting Method}
The box-counting method is a practical way to calculate the fractal dimension. The space is covered with a grid of boxes, and the number of boxes \( N(\epsilon) \) that contain a part of the fractal is counted. The fractal dimension \( D \) is then estimated by the slope of the line in a log-log plot of \( N(\epsilon) \) versus \( \epsilon \).

\subsection{The Sandbox Method}
The sandbox method involves counting the number of points within a radius \( r \) from a central point. The fractal dimension is determined by:
\[
D = \lim_{r \to 0} \frac{\log M(r)}{\log r}
\]
where \( M(r) \) is the number of points within the radius \( r \).

\subsection{The Correlation-Function Method}
This method calculates the correlation function \( C(r) \), which measures how the density of points in a fractal is correlated over distance \( r \). The correlation dimension \( D_2 \) is given by:
\[
D_2 = \lim_{r \to 0} \frac{\log C(r)}{\log r}
\]

\subsection{Correlation Length \( \xi \)}
The correlation length \( \xi \) is a measure of the size of clusters in a percolation system. Near the critical point \( p_c \), \( \xi \) diverges as:
\[
\xi \sim |p - p_c|^{-\nu}
\]
where \( \nu \) is the correlation length exponent.

\subsection{Finite Size Effects}
Finite-size effects refer to the deviations in the behavior of a system due to its finite size, especially near critical points. In percolation theory, finite-size scaling is used to extrapolate the behavior of an infinite system from simulations of finite systems.

\subsection{Fractal Dimension in Percolation}
The fractal dimension of a percolation cluster at the critical point \( p_c \) can be determined using methods like box counting or sandbox method. The fractal dimension \( D_f \) relates the mass \( M \) of the cluster to its size \( R \) by:
\[
M \sim R^{D_f}
\]

\subsection{Examples}
Examples of fractals include the Mandelbrot set, Sierpinski triangle, and Koch snowflake. Each of these exhibits self-similarity and can be described by a non-integer fractal dimension.

\subsection{Cellular Automata}
Cellular automata are discrete models used in computational simulations. A cellular automaton consists of a grid of cells, each of which can be in a finite number of states. The state of each cell evolves over discrete time steps according to a set of rules based on the states of neighboring cells.

\section{Monte Carlo Methods}
\subsection{What is ``Monte Carlo"?}
Monte Carlo methods are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. These methods are particularly useful for high-dimensional integrals, optimization problems, and systems with a large degree of uncertainty.

\subsection{Applications of Monte Carlo}
Monte Carlo methods are applied in areas such as statistical physics, financial modeling, risk analysis, and many others. For example, in statistical physics, they are used to simulate the behavior of particles in a system at thermal equilibrium.

\subsection{Computation of Integrals}
Monte Carlo integration estimates the value of a definite integral by randomly sampling points in the domain and averaging the function values at those points. For an integral over a domain \( D \):
\[
I = \int_D f(x) \, dx \approx \frac{1}{N} \sum_{i=1}^N f(x_i)
\]
where \( x_i \) are random samples from \( D \), and \( N \) is the number of samples.

\subsection{Higher Dimensional Integrals}
Monte Carlo methods are particularly powerful for high-dimensional integrals, where traditional numerical integration methods become computationally expensive. The accuracy of Monte Carlo integration scales as \( \frac{1}{\sqrt{N}} \), independent of the dimensionality.

\subsection{Canonical Monte Carlo}
Canonical Monte Carlo refers to simulations performed in the canonical ensemble, where the system is in thermal equilibrium at a fixed temperature. The probability of the system being in a state \( i \) is given by the Boltzmann distribution:
\[
P_i = \frac{e^{-\beta E_i}}{Z}
\]
where \( \beta = \frac{1}{k_B T} \), \( E_i \) is the energy of state \( i \), and \( Z \) is the partition function.

\subsection{The Ising Model}
The Ising model is a mathematical model of ferromagnetism in statistical physics. It consists of spins \( \sigma_i \) on a lattice, where each spin can take values \( \pm 1 \). The energy of the system is given by:
\[
E = -J \sum_{\langle i,j \rangle} \sigma_i \sigma_j - h \sum_i \sigma_i
\]
where \( J \) is the interaction strength, \( h \) is the external magnetic field, and the first sum is over nearest neighbors.

\subsection{Interfaces}
In Monte Carlo simulations, interfaces refer to the boundaries between different phases or regions in a system. The study of interfaces is important in understanding phenomena such as surface tension, phase separation, and domain growth.

\subsection{Simulation Examples}
Examples of Monte Carlo simulations include the simulation ofHere's the continuation of the enhanced LaTeX lecture notes with additional detailed explanations of the mathematical formulas and content:

```latex
\maketitle
\tableofcontents
\newpage

\part{Stochastic Processes}
\section{Random Numbers}
\subsection{Definition of Random Numbers}
Random numbers are sequences of numbers that lack any predictable pattern. In computational simulations, random numbers are crucial for stochastic modeling, Monte Carlo methods, and simulations involving randomness.

\subsection{Congruential RNG (Multiplicative)}
The congruential method is a simple and widely used random number generator (RNG). The multiplicative congruential method generates a sequence of random numbers \( X_n \) using the recursive relation:
\[
X_{n+1} = (a \cdot X_n + c) \mod m
\]
where \( a \) is the multiplier, \( c \) is the increment, \( m \) is the modulus, and \( X_0 \) is the seed. The choice of parameters \( a \), \( c \), and \( m \) is crucial for the quality of the RNG.

\subsection{Lagged Fibonacci RNG (Additive)}
The Lagged Fibonacci RNG is an advanced RNG that uses a sequence of lagged terms. The general formula is:
\[
X_n = (X_{n-j} \circ X_{n-k}) \mod m
\]
where \( j \) and \( k \) are lags, and \( \circ \) represents an operation such as addition, subtraction, or multiplication. This RNG can produce a longer period and better statistical properties than simpler methods.

\subsection{How Good is a RNG?}
The quality of an RNG is assessed by its period, uniformity, and independence. The period is the length before the sequence repeats. A good RNG should also pass statistical tests for uniformity and independence, such as the chi-square test, Kolmogorov-Smirnov test, and autocorrelation test.

\subsection{Non-Uniform Distributions}
Many applications require random numbers from non-uniform distributions, such as Gaussian or exponential distributions. Non-uniform random numbers can be generated by transforming uniform random numbers using methods like the inverse transform, Box-Muller, or acceptance-rejection methods.

\section{Percolation}
\subsection{The Sol-Gel Transition}
Percolation theory studies the behavior of connected clusters in a random graph. The sol-gel transition refers to the process where a system transitions from a liquid-like state (sol) to a solid-like state (gel) as clusters percolate through the system.

\subsection{The Percolation Model}
The percolation model is a mathematical model used to study the formation of connected clusters in a lattice. In a lattice of sites, each site is occupied with probability \( p \). Percolation occurs when a cluster spans from one side of the lattice to the opposite side, which happens at a critical probability \( p_c \).

\section{Fractals}
\subsection{Self-Similarity}
A fractal is a complex geometric shape that exhibits self-similarity, meaning that parts of the fractal are similar to the whole. Mathematically, a self-similar object satisfies:
\[
f(x) = \lambda f(\lambda x)
\]
for some scaling factor \( \lambda \).

\subsection{Fractal Dimension: Mathematical Definition}
The fractal dimension \( D \) quantifies the complexity of a fractal by describing how the detail in a pattern changes with the scale at which it is measured. The fractal dimension can be calculated using:
\[
D = \lim_{\epsilon \to 0} \frac{\log N(\epsilon)}{\log \frac{1}{\epsilon}}
\]
where \( N(\epsilon) \) is the number of self-similar pieces of size \( \epsilon \).

\subsection{The Box Counting Method}
The box-counting method is a practical way to calculate the fractal dimension. The space is covered with a grid of boxes, and the number of boxes \( N(\epsilon) \) that contain a part of the fractal is counted. The fractal dimension \( D \) is then estimated by the slope of the line in a log-log plot of \( N(\epsilon) \) versus \( \epsilon \).

\subsection{The Sandbox Method}
The sandbox method involves counting the number of points within a radius \( r \) from a central point. The fractal dimension is determined by:
\[
D = \lim_{r \to 0} \frac{\log M(r)}{\log r}
\]
where \( M(r) \) is the number of points within the radius \( r \).

\subsection{The Correlation-Function Method}
This method calculates the correlation function \( C(r) \), which measures how the density of points in a fractal is correlated over distance \( r \). The correlation dimension \( D_2 \) is given by:
\[
D_2 = \lim_{r \to 0} \frac{\log C(r)}{\log r}
\]

\subsection{Correlation Length \( \xi \)}
The correlation length \( \xi \) is a measure of the size of clusters in a percolation system. Near the critical point \( p_c \), \( \xi \) diverges as:
\[
\xi \sim |p - p_c|^{-\nu}
\]
where \( \nu \) is the correlation length exponent.

\subsection{Finite Size Effects}
Finite-size effects refer to the deviations in the behavior of a system due to its finite size, especially near critical points. In percolation theory, finite-size scaling is used to extrapolate the behavior of an infinite system from simulations of finite systems.

\subsection{Fractal Dimension in Percolation}
The fractal dimension of a percolation cluster at the critical point \( p_c \) can be determined using methods like box counting or sandbox method. The fractal dimension \( D_f \) relates the mass \( M \) of the cluster to its size \( R \) by:
\[
M \sim R^{D_f}
\]

\subsection{Examples}
Examples of fractals include the Mandelbrot set, Sierpinski triangle, and Koch snowflake. Each of these exhibits self-similarity and can be described by a non-integer fractal dimension.

\subsection{Cellular Automata}
Cellular automata are discrete models used in computational simulations. A cellular automaton consists of a grid of cells, each of which can be in a finite number of states. The state of each cell evolves over discrete time steps according to a set of rules based on the states of neighboring cells.

\section{Monte Carlo Methods}
\subsection{What is ``Monte Carlo"?}
Monte Carlo methods are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. These methods are particularly useful for high-dimensional integrals, optimization problems, and systems with a large degree of uncertainty.

\subsection{Applications of Monte Carlo}
Monte Carlo methods are applied in areas such as statistical physics, financial modeling, risk analysis, and many others. For example, in statistical physics, they are used to simulate the behavior of particles in a system at thermal equilibrium.

\subsection{Computation of Integrals}
Monte Carlo integration estimates the value of a definite integral by randomly sampling points in the domain and averaging the function values at those points. For an integral over a domain \( D \):
\[
I = \int_D f(x) \, dx \approx \frac{1}{N} \sum_{i=1}^N f(x_i)
\]
where \( x_i \) are random samples from \( D \), and \( N \) is the number of samples.

\subsection{Higher Dimensional Integrals}
Monte Carlo methods are particularly powerful for high-dimensional integrals, where traditional numerical integration methods become computationally expensive. The accuracy of Monte Carlo integration scales as \( \frac{1}{\sqrt{N}} \), independent of the dimensionality.

\subsection{Canonical Monte Carlo}
Canonical Monte Carlo refers to simulations performed in the canonical ensemble, where the system is in thermal equilibrium at a fixed temperature. The probability of the system being in a state \( i \) is given by the Boltzmann distribution:
\[
P_i = \frac{e^{-\beta E_i}}{Z}
\]
where \( \beta = \frac{1}{k_B T} \), \( E_i \) is the energy of state \( i \), and \( Z \) is the partition function.

\subsection{The Ising Model}
The Ising model is a mathematical model of ferromagnetism in statistical physics. It consists of spins \( \sigma_i \) on a lattice, where each spin can take values \( \pm 1 \). The energy of the system is given by:
\[
E = -J \sum_{\langle i,j \rangle} \sigma_i \sigma_j - h \sum_i \sigma_i
\]
where \( J \) is the interaction strength, \( h \) is the external magnetic field, and the first sum is over nearest neighbors.

\subsection{Interfaces}
In Monte Carlo simulations, interfaces refer to the boundaries between different phases or regions in a system. The study of interfaces is important in understanding phenomena such as surface tension, phase separation, and domain growth.

\subsection{Simulation Examples}
Examples of Monte Carlo simulations include the simulation of particle systems, pricing of financial derivatives, and the study of phase transitions in physical systems.

\part{Solving Systems of Equations Numerically}
\section{Solving Equations}
\subsection{One-Dimensional Case}
In the one-dimensional case, solving an equationCertainly! Below is the continuation and completion of the enhanced LaTeX lecture notes with detailed explanations for the mathematical formulas and additional content:

```latex
% Continuation of the document
\section{Solving Equations}
\subsection{One-Dimensional Case}
In the one-dimensional case, solving an equation \( f(x) = 0 \) involves finding the roots of the function \( f(x) \). Several numerical methods can be used to solve this, including:

\paragraph{Bisection Method:}
The bisection method is a simple iterative algorithm for finding roots of a continuous function. It works by repeatedly bisecting an interval and selecting the subinterval in which the function changes sign. Given an initial interval \([a, b]\) where \( f(a) \) and \( f(b) \) have opposite signs, the method proceeds as:
\[
c = \frac{a + b}{2}
\]
If \( f(c) \) has the opposite sign to \( f(a) \), set \( b = c \); otherwise, set \( a = c \). This process continues until the interval is sufficiently small.

\paragraph{Newton-Raphson Method:}
The Newton-Raphson method is an iterative technique for finding successively better approximations to the roots of a real-valued function. Starting with an initial guess \( x_0 \), the method uses the formula:
\[
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
\]
where \( f'(x_n) \) is the derivative of \( f(x) \) at \( x_n \). The process is repeated until \( |x_{n+1} - x_n| \) is smaller than a predefined tolerance.

\subsection{Multi-Dimensional Case}
In multiple dimensions, solving a system of equations involves finding the roots of a vector-valued function \( \mathbf{F}(\mathbf{x}) = \mathbf{0} \), where \( \mathbf{x} \) is a vector of variables and \( \mathbf{F} \) is a vector of functions. 

\paragraph{Newton's Method for Multidimensional Systems:}
Newton's method can be extended to multiple dimensions. The iterative formula in this case is:
\[
\mathbf{x}_{n+1} = \mathbf{x}_n - \mathbf{J}^{-1}(\mathbf{x}_n) \mathbf{F}(\mathbf{x}_n)
\]
where \( \mathbf{J}(\mathbf{x}_n) \) is the Jacobian matrix of partial derivatives of \( \mathbf{F} \) at \( \mathbf{x}_n \).

\section{Linear Systems of Equations}
\subsection{Gaussian Elimination}
Gaussian elimination is a method for solving linear systems of equations. It systematically reduces the system to upper triangular form using row operations, after which back substitution is used to find the solution. The steps are:

1. Forward elimination to form an upper triangular matrix.
2. Back substitution to solve for the unknowns.

\subsection{LU Decomposition}
LU decomposition is a method of decomposing a matrix \( A \) into a product of a lower triangular matrix \( L \) and an upper triangular matrix \( U \):
\[
A = LU
\]
Once the matrix is decomposed, solving \( A\mathbf{x} = \mathbf{b} \) is reduced to solving two simpler systems: \( L\mathbf{y} = \mathbf{b} \) and \( U\mathbf{x} = \mathbf{y} \).

\subsection{Iterative Methods}
Iterative methods, such as Jacobi and Gauss-Seidel, are used to solve large systems of linear equations where direct methods like Gaussian elimination are computationally expensive. These methods start with an initial guess and iteratively refine the solution.

\paragraph{Jacobi Method:}
In the Jacobi method, each equation is solved for its corresponding variable assuming the other variables are constant. The process is iterated:
\[
x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j \neq i} a_{ij} x_j^{(k)} \right)
\]
where \( a_{ij} \) are the coefficients of the matrix \( A \), and \( b_i \) are the components of the vector \( \mathbf{b} \).

\paragraph{Gauss-Seidel Method:}
The Gauss-Seidel method is an improvement over the Jacobi method, where each variable is updated as soon as its new value is computed:
\[
x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j < i} a_{ij} x_j^{(k+1)} - \sum_{j > i} a_{ij} x_j^{(k)} \right)
\]
This often leads to faster convergence.

\section{Eigenvalues and Eigenvectors}
\subsection{Definition}
For a square matrix \( A \), an eigenvalue \( \lambda \) and corresponding eigenvector \( \mathbf{v} \) satisfy the equation:
\[
A\mathbf{v} = \lambda\mathbf{v}
\]
Eigenvalues and eigenvectors play a crucial role in various applications, including stability analysis, vibrations, and quantum mechanics.

\subsection{Power Method}
The power method is an iterative technique used to find the largest eigenvalue and corresponding eigenvector of a matrix. Starting with an arbitrary vector \( \mathbf{v}_0 \), the method computes:
\[
\mathbf{v}_{n+1} = \frac{A\mathbf{v}_n}{\|A\mathbf{v}_n\|}
\]
The vector \( \mathbf{v}_n \) converges to the eigenvector corresponding to the largest eigenvalue of \( A \).

\section{Ordinary Differential Equations (ODEs)}
\subsection{Initial Value Problems (IVPs)}
An initial value problem for an ODE involves finding a function \( y(t) \) that satisfies the differential equation \( \frac{dy}{dt} = f(t, y) \) with an initial condition \( y(t_0) = y_0 \).

\paragraph{Euler's Method:}
Euler's method is a simple numerical technique for solving IVPs. Starting from \( (t_0, y_0) \), the solution is approximated using:
\[
y_{n+1} = y_n + h f(t_n, y_n)
\]
where \( h \) is the step size.

\paragraph{Runge-Kutta Methods:}
Runge-Kutta methods are a family of iterative methods that provide higher accuracy than Euler's method. The most common is the fourth-order Runge-Kutta (RK4) method, given by:
\[
y_{n+1} = y_n + \frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)
\]
where
\[
k_1 = f(t_n, y_n), \quad k_2 = f\left(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_1\right)
\]
\[
k_3 = f\left(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_2\right), \quad k_4 = f(t_n + h, y_n + h k_3)
\]

\subsection{Boundary Value Problems (BVPs)}
Boundary value problems involve finding a solution to an ODE that satisfies boundary conditions at more than one point. Common methods for solving BVPs include the shooting method and finite difference method.

\paragraph{Shooting Method:}
The shooting method converts a BVP into an IVP. By guessing the initial conditions and integrating the ODE, the solution is adjusted iteratively to satisfy the boundary conditions.

\paragraph{Finite Difference Method:}
The finite difference method discretizes the domain and approximates the differential equation by replacing derivatives with difference equations. The resulting system of algebraic equations is then solved numerically.

\section{Partial Differential Equations (PDEs)}
\subsection{Classification of PDEs}
Partial differential equations are classified into three main types based on their form:

\paragraph{Elliptic PDEs:}
Elliptic PDEs, like the Laplace equation \( \nabla^2 u = 0 \), arise in steady-state problems and describe equilibrium states.

\paragraph{Parabolic PDEs:}
Parabolic PDEs, such as the heat equation \( \frac{\partial u}{\partial t} = \alpha \nabla^2 u \), describe diffusion processes and are used in time-dependent problems.

\paragraph{Hyperbolic PDEs:}
Hyperbolic PDEs, like the wave equation \( \frac{\partial^2 u}{\partial t^2} = c^2 \nabla^2 u \), model wave propagation and other dynamic phenomena.

\subsection{Numerical Methods for PDEs}
Numerical methods for solving PDEs include finite difference, finite element, and finite volume methods. These methods discretize the domain and solve the resulting algebraic system to approximate the solution of the PDE.

\section{Optimization Problems}
\subsection{Unconstrained Optimization}
Unconstrained optimization involves finding the minimum or maximum of a function \( f(x) \) without any constraints. Common methods include:

\paragraph{Gradient Descent:}
Gradient descent is an iterative method where the function \( f(x) \) is minimized by moving in the direction of the negative gradient:
\[
x_{n+1Certainly! Here's the detailed continuation of the lecture notes with explanations and mathematical formulas added to the LaTeX file:

```latex
% Continuation of the document
\section{Optimization Problems}
\subsection{Unconstrained Optimization}
Unconstrained optimization involves finding the minimum or maximum of a function \( f(x) \) without any constraints. Common methods include:

\paragraph{Gradient Descent:}
Gradient descent is an iterative method where the function \( f(x) \) is minimized by moving in the direction of the negative gradient:
\[
x_{n+1} = x_n - \alpha \nabla f(x_n)
\]
where \( \alpha \) is the step size, and \( \nabla f(x_n) \) is the gradient of the function at \( x_n \). This method is widely used in machine learning and data fitting.

\paragraph{Newton's Method:}
Newton's method for optimization uses the second-order Taylor expansion to find the minimum:
\[
x_{n+1} = x_n - H_f^{-1}(x_n) \nabla f(x_n)
\]
where \( H_f(x_n) \) is the Hessian matrix (matrix of second-order partial derivatives) of \( f(x) \) at \( x_n \). Newton's method converges faster than gradient descent but requires the computation of the Hessian, which can be computationally expensive.

\subsection{Constrained Optimization}
Constrained optimization deals with optimizing a function subject to constraints \( g_i(x) \leq 0 \) and \( h_j(x) = 0 \). Techniques include:

\paragraph{Lagrange Multipliers:}
To solve a constrained optimization problem, the method of Lagrange multipliers introduces a new variable (multiplier) for each constraint, converting the problem into finding the stationary points of the Lagrange function:
\[
\mathcal{L}(x, \lambda) = f(x) + \sum_{i} \lambda_i g_i(x)
\]
where \( \lambda_i \) are the Lagrange multipliers associated with the constraints \( g_i(x) \).

\paragraph{Karush-Kuhn-Tucker (KKT) Conditions:}
The KKT conditions are necessary conditions for a solution in non-linear programming to be optimal. For a problem with constraints, the KKT conditions generalize the method of Lagrange multipliers by incorporating inequality constraints. The conditions include primal feasibility, dual feasibility, stationarity, and complementary slackness.

\section{Fourier Transforms}
\subsection{Introduction to Fourier Transforms}
Fourier transforms are mathematical tools that decompose a function into its constituent frequencies. They are widely used in signal processing, physics, and engineering.

\paragraph{Fourier Series:}
For periodic functions, the Fourier series represents the function as a sum of sines and cosines:
\[
f(x) = a_0 + \sum_{n=1}^{\infty} \left( a_n \cos \frac{2\pi n x}{L} + b_n \sin \frac{2\pi n x}{L} \right)
\]
where \( L \) is the period, and \( a_n \) and \( b_n \) are the Fourier coefficients.

\paragraph{Fourier Transform:}
The Fourier transform generalizes the Fourier series to non-periodic functions. For a function \( f(x) \), the Fourier transform \( F(k) \) is defined as:
\[
F(k) = \int_{-\infty}^{\infty} f(x) e^{-2\pi i k x} dx
\]
The inverse Fourier transform recovers the original function:
\[
f(x) = \int_{-\infty}^{\infty} F(k) e^{2\pi i k x} dk
\]

\subsection{Properties of Fourier Transforms}
Key properties of Fourier transforms include:

\paragraph{Linearity:}
The Fourier transform of a linear combination of functions is the same linear combination of their Fourier transforms.

\paragraph{Scaling:}
If \( f(ax) \) is the scaled function, its Fourier transform scales inversely in frequency:
\[
\text{If } f(x) \leftrightarrow F(k), \text{ then } f(ax) \leftrightarrow \frac{1}{|a|}F\left(\frac{k}{a}\right)
\]

\paragraph{Shift:}
A shift in the time domain corresponds to a phase shift in the frequency domain:
\[
\text{If } f(x) \leftrightarrow F(k), \text{ then } f(x - x_0) \leftrightarrow e^{-2\pi i k x_0} F(k)
\]

\paragraph{Convolution:}
The convolution of two functions in the time domain corresponds to multiplication in the frequency domain:
\[
f(x) * g(x) \leftrightarrow F(k) G(k)
\]
where \( * \) denotes convolution.

\subsection{Applications of Fourier Transforms}
Fourier transforms are used in various fields:

\paragraph{Signal Processing:}
In signal processing, Fourier transforms analyze the frequency content of signals, filter signals, and reconstruct signals from their frequency components.

\paragraph{Quantum Mechanics:}
In quantum mechanics, the wave function's Fourier transform gives the momentum-space representation, linking position and momentum representations.

\paragraph{Image Processing:}
In image processing, Fourier transforms are used for tasks like image filtering, compression, and feature extraction.

\section{Numerical Integration}
\subsection{Basic Concepts}
Numerical integration involves approximating the value of an integral when an exact analytical solution is difficult or impossible to obtain. Common methods include:

\paragraph{Trapezoidal Rule:}
The trapezoidal rule approximates the integral by dividing the area under the curve into trapezoids and summing their areas:
\[
\int_a^b f(x) dx \approx \frac{b-a}{2} [f(a) + f(b)] + \sum_{i=1}^{n-1} f(x_i)
\]

\paragraph{Simpson's Rule:}
Simpson's rule approximates the integral by fitting a quadratic polynomial through every three consecutive points:
\[
\int_a^b f(x) dx \approx \frac{b-a}{6} [f(a) + 4f\left(\frac{a+b}{2}\right) + f(b)]
\]

\subsection{Adaptive Quadrature}
Adaptive quadrature methods adjust the integration interval dynamically to achieve a specified accuracy, making them more efficient for functions with varying smoothness.

\paragraph{Romberg Integration:}
Romberg integration uses the trapezoidal rule iteratively with Richardson extrapolation to improve accuracy:
\[
R_{k+1,j} = \frac{4^j R_{k+1,j-1} - R_{k,j-1}}{4^j - 1}
\]
where \( R_{k,j} \) represents the refined estimate at step \( k \) and level \( j \).

\paragraph{Gaussian Quadrature:}
Gaussian quadrature provides an exact result for polynomials of degree \( 2n-1 \) or less by choosing optimal sample points (Gauss points) and weights:
\[
\int_a^b f(x) dx \approx \sum_{i=1}^n w_i f(x_i)
\]
where \( w_i \) are the weights and \( x_i \) are the Gauss points.

\section{Advanced Topics in Numerical Methods}
\subsection{Finite Element Method (FEM)}
The finite element method is a powerful numerical technique for solving PDEs, especially in engineering and physics. It involves discretizing the domain into elements and approximating the solution by piecewise polynomial functions.

\paragraph{Weak Formulation:}
In FEM, the PDE is reformulated in its weak form, where the solution space is approximated by a finite-dimensional subspace. The weak formulation ensures better handling of boundary conditions and irregular geometries.

\paragraph{Assembly of the Global System:}
The local element equations are assembled into a global system of equations. This system is then solved to obtain the approximate solution over the entire domain.

\subsection{Spectral Methods}
Spectral methods solve PDEs by expanding the solution in terms of global basis functions, typically trigonometric polynomials or orthogonal polynomials.

\paragraph{Galerkin Method:}
The Galerkin method is a spectral method where the residual of the PDE is made orthogonal to the basis functions:
\[
\int \text{Residual} \times \text{Basis Function} = 0
\]
This leads to a system of equations for the coefficients of the expansion.

\paragraph{Chebyshev Polynomials:}
Chebyshev polynomials are often used in spectral methods due to their superior convergence properties for approximating functions with boundary layers or singularities.

\section{Computational Efficiency and Stability}
\subsection{Stability of Numerical Methods}
Stability refers to the behavior of numerical solutions as the step size or grid size changes. A stable method ensures that small perturbations in input or intermediate steps do not lead to large deviations in the output.

\paragraph{Von Neumann Stability Analysis:}
Von Neumann stability analysis is used to analyze the stability of finite difference schemes by examining the growth of Fourier modes in the numerical solution.

\paragraph{Condition Number:}
The condition number of a matrix measures the sensitivity of the solution of a linear system to perturbations in the input data. A high condition number indicates potential numerical instability.

\subsection{Computational Complexity}
Computational complexity concerns the resources required by an algorithm, such as time and memory. Algorithms are analyzed for their time complexity (e.g., \( O(nHere is the final version of the LaTeX document, which includes explanations for the mathematical formulas and the additional sections on optimization problems, Fourier transforms, numerical integration, and advanced numerical methods:

```latex
\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\title{Numerical Methods Lecture Notes}
\author{Your Name}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}
Numerical methods are a set of techniques used to solve mathematical problems that are difficult or impossible to solve analytically. These methods are essential in fields such as engineering, physics, computer science, and finance.

\section{Solving Equations}
\subsection{One-Dimensional Case}
In the one-dimensional case, solving an equation \( f(x) = 0 \) involves finding the roots of the function \( f(x) \). Several numerical methods can be used to solve this, including:

\paragraph{Bisection Method:}
The bisection method is a simple iterative algorithm for finding roots of a continuous function. It works by repeatedly bisecting an interval and selecting the subinterval in which the function changes sign. Given an initial interval \([a, b]\) where \( f(a) \) and \( f(b) \) have opposite signs, the method proceeds as:
\[
c = \frac{a + b}{2}
\]
If \( f(c) \) has the opposite sign to \( f(a) \), set \( b = c \); otherwise, set \( a = c \). This process continues until the interval is sufficiently small.

\paragraph{Newton-Raphson Method:}
The Newton-Raphson method is an iterative technique for finding successively better approximations to the roots of a real-valued function. Starting with an initial guess \( x_0 \), the method uses the formula:
\[
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
\]
where \( f'(x_n) \) is the derivative of \( f(x) \) at \( x_n \). The process is repeated until \( |x_{n+1} - x_n| \) is smaller than a predefined tolerance.

\subsection{Multi-Dimensional Case}
In multiple dimensions, solving a system of equations involves finding the roots of a vector-valued function \( \mathbf{F}(\mathbf{x}) = \mathbf{0} \), where \( \mathbf{x} \) is a vector of variables and \( \mathbf{F} \) is a vector of functions. 

\paragraph{Newton's Method for Multidimensional Systems:}
Newton's method can be extended to multiple dimensions. The iterative formula in this case is:
\[
\mathbf{x}_{n+1} = \mathbf{x}_n - \mathbf{J}^{-1}(\mathbf{x}_n) \mathbf{F}(\mathbf{x}_n)
\]
where \( \mathbf{J}(\mathbf{x}_n) \) is the Jacobian matrix of partial derivatives of \( \mathbf{F} \) at \( \mathbf{x}_n \).

\section{Linear Systems of Equations}
\subsection{Gaussian Elimination}
Gaussian elimination is a method for solving linear systems of equations. It systematically reduces the system to upper triangular form using row operations, after which back substitution is used to find the solution. The steps are:

1. Forward elimination to form an upper triangular matrix.
2. Back substitution to solve for the unknowns.

\subsection{LU Decomposition}
LU decomposition is a method of decomposing a matrix \( A \) into a product of a lower triangular matrix \( L \) and an upper triangular matrix \( U \):
\[
A = LU
\]
Once the matrix is decomposed, solving \( A\mathbf{x} = \mathbf{b} \) is reduced to solving two simpler systems: \( L\mathbf{y} = \mathbf{b} \) and \( U\mathbf{x} = \mathbf{y} \).

\subsection{Iterative Methods}
Iterative methods, such as Jacobi and Gauss-Seidel, are used to solve large systems of linear equations where direct methods like Gaussian elimination are computationally expensive. These methods start with an initial guess and iteratively refine the solution.

\paragraph{Jacobi Method:}
In the Jacobi method, each equation is solved for its corresponding variable assuming the other variables are constant. The process is iterated:
\[
x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j \neq i} a_{ij} x_j^{(k)} \right)
\]
where \( a_{ij} \) are the coefficients of the matrix \( A \), and \( b_i \) are the components of the vector \( \mathbf{b} \).

\paragraph{Gauss-Seidel Method:}
The Gauss-Seidel method is an improvement over the Jacobi method, where each variable is updated as soon as its new value is computed:
\[
x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j < i} a_{ij} x_j^{(k+1)} - \sum_{j > i} a_{ij} x_j^{(k)} \right)
\]
This often leads to faster convergence.

\section{Eigenvalues and Eigenvectors}
\subsection{Definition}
For a square matrix \( A \), an eigenvalue \( \lambda \) and corresponding eigenvector \( \mathbf{v} \) satisfy the equation:
\[
A\mathbf{v} = \lambda\mathbf{v}
\]
Eigenvalues and eigenvectors play a crucial role in various applications, including stability analysis, vibrations, and quantum mechanics.

\subsection{Power Method}
The power method is an iterative technique used to find the largest eigenvalue and corresponding eigenvector of a matrix. Starting with an arbitrary vector \( \mathbf{v}_0 \), the method computes:
\[
\mathbf{v}_{n+1} = \frac{A\mathbf{v}_n}{\|A\mathbf{v}_n\|}
\]
The vector \( \mathbf{v}_n \) converges to the eigenvector corresponding to the largest eigenvalue of \( A \).

\section{Ordinary Differential Equations (ODEs)}
\subsection{Initial Value Problems (IVPs)}
An initial value problem for an ODE involves finding a function \( y(t) \) that satisfies the differential equation \( \frac{dy}{dt} = f(t, y) \) with an initial condition \( y(t_0) = y_0 \).

\paragraph{Euler's Method:}
Euler's method is a simple numerical technique for solving IVPs. Starting from \( (t_0, y_0) \), the solution is approximated using:
\[
y_{n+1} = y_n + h f(t_n, y_n)
\]
where \( h \) is the step size.

\paragraph{Runge-Kutta Methods:}
Runge-Kutta methods are a family of iterative methods that provide higher accuracy than Euler's method. The most common is the fourth-order Runge-Kutta (RK4) method, given by:
\[
y_{n+1} = y_n + \frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)
\]
where
\[
k_1 = f(t_n, y_n), \quad k_2 = f\left(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_1\right)
\]
\[
k_3 = f\left(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_2\right), \quad k_4 = f(t_n + h, y_n + h k_3)
\]

\subsection{Boundary Value Problems (BVPs)}
Boundary value problems involve finding a solution to an ODE that satisfies boundary conditions at more than one point. Common methods for solving BVPs include the shooting method and finite difference method.

\paragraph{Shooting Method:}
The shooting method converts a BVP into an IVP. By guessing the initial conditions and integrating the ODE, the solution is adjusted iteratively to satisfy the boundary conditions.

\paragraph{Finite Difference Method:}
The finite difference method discretizes the domain and approximates the differential equation by replacing derivatives with difference equations. The resulting system of algebraic equations is then solved numerically.

\section{Partial Differential Equations (PDEs)}
\subsection{Classification of PDEs}
Partial differential equations are classified into three main types based on their form:

\paragraph{Elliptic PDEs:}
Elliptic PDEs, like the Laplace equation \( \nabla^2 u = 0 \), arise in steady-state problems and describe equilibrium states.

\paragraph{Parabolic PDEs:}
Parabolic PDEs, such as the heat equation \( \frac{\partial u}{\partial t} = \alpha \nabla^2 u \), describe diffusion processes and are used in time-dependent problems.

\paragraph{Hyperbolic PDEs:}
Hyperbolic PDEs, like the wave equation \( \frac{\partial^2 u}{\partial t^2} = c^2 \nabla^2 u \), model wave propagation and other dynamic phenomena.

\subsection{Numerical Methods for PDEs}
Numerical methods for solving PDEs include finite differenceThe continuation of the lecture notes now includes detailed explanations for the mathematical formulas and additional sections on optimization problems, Fourier transforms, numerical integration, and advanced numerical methods. Here is the updated LaTeX code:

```latex
\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\title{Numerical Methods Lecture Notes}
\author{Your Name}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}
Numerical methods are a set of techniques used to solve mathematical problems that are difficult or impossible to solve analytically. These methods are essential in fields such as engineering, physics, computer science, and finance.

\section{Solving Equations}
\subsection{One-Dimensional Case}
In the one-dimensional case, solving an equation \( f(x) = 0 \) involves finding the roots of the function \( f(x) \). Several numerical methods can be used to solve this, including:

\paragraph{Bisection Method:}
The bisection method is a simple iterative algorithm for finding roots of a continuous function. It works by repeatedly bisecting an interval and selecting the subinterval in which the function changes sign. Given an initial interval \([a, b]\) where \( f(a) \) and \( f(b) \) have opposite signs, the method proceeds as:
\[
c = \frac{a + b}{2}
\]
If \( f(c) \) has the opposite sign to \( f(a) \), set \( b = c \); otherwise, set \( a = c \). This process continues until the interval is sufficiently small.

\paragraph{Newton-Raphson Method:}
The Newton-Raphson method is an iterative technique for finding successively better approximations to the roots of a real-valued function. Starting with an initial guess \( x_0 \), the method uses the formula:
\[
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
\]
where \( f'(x_n) \) is the derivative of \( f(x) \) at \( x_n \). The process is repeated until \( |x_{n+1} - x_n| \) is smaller than a predefined tolerance.

\subsection{Multi-Dimensional Case}
In multiple dimensions, solving a system of equations involves finding the roots of a vector-valued function \( \mathbf{F}(\mathbf{x}) = \mathbf{0} \), where \( \mathbf{x} \) is a vector of variables and \( \mathbf{F} \) is a vector of functions. 

\paragraph{Newton's Method for Multidimensional Systems:}
Newton's method can be extended to multiple dimensions. The iterative formula in this case is:
\[
\mathbf{x}_{n+1} = \mathbf{x}_n - \mathbf{J}^{-1}(\mathbf{x}_n) \mathbf{F}(\mathbf{x}_n)
\]
where \( \mathbf{J}(\mathbf{x}_n) \) is the Jacobian matrix of partial derivatives of \( \mathbf{F} \) at \( \mathbf{x}_n \).

\section{Linear Systems of Equations}
\subsection{Gaussian Elimination}
Gaussian elimination is a method for solving linear systems of equations. It systematically reduces the system to upper triangular form using row operations, after which back substitution is used to find the solution. The steps are:

1. Forward elimination to form an upper triangular matrix.
2. Back substitution to solve for the unknowns.

\subsection{LU Decomposition}
LU decomposition is a method of decomposing a matrix \( A \) into a product of a lower triangular matrix \( L \) and an upper triangular matrix \( U \):
\[
A = LU
\]
Once the matrix is decomposed, solving \( A\mathbf{x} = \mathbf{b} \) is reduced to solving two simpler systems: \( L\mathbf{y} = \mathbf{b} \) and \( U\mathbf{x} = \mathbf{y} \).

\subsection{Iterative Methods}
Iterative methods, such as Jacobi and Gauss-Seidel, are used to solve large systems of linear equations where direct methods like Gaussian elimination are computationally expensive. These methods start with an initial guess and iteratively refine the solution.

\paragraph{Jacobi Method:}
In the Jacobi method, each equation is solved for its corresponding variable assuming the other variables are constant. The process is iterated:
\[
x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j \neq i} a_{ij} x_j^{(k)} \right)
\]
where \( a_{ij} \) are the coefficients of the matrix \( A \), and \( b_i \) are the components of the vector \( \mathbf{b} \).

\paragraph{Gauss-Seidel Method:}
The Gauss-Seidel method is an improvement over the Jacobi method, where each variable is updated as soon as its new value is computed:
\[
x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j < i} a_{ij} x_j^{(k+1)} - \sum_{j > i} a_{ij} x_j^{(k)} \right)
\]
This often leads to faster convergence.

\section{Eigenvalues and Eigenvectors}
\subsection{Definition}
For a square matrix \( A \), an eigenvalue \( \lambda \) and corresponding eigenvector \( \mathbf{v} \) satisfy the equation:
\[
A\mathbf{v} = \lambda\mathbf{v}
\]
Eigenvalues and eigenvectors play a crucial role in various applications, including stability analysis, vibrations, and quantum mechanics.

\subsection{Power Method}
The power method is an iterative technique used to find the largest eigenvalue and corresponding eigenvector of a matrix. Starting with an arbitrary vector \( \mathbf{v}_0 \), the method computes:
\[
\mathbf{v}_{n+1} = \frac{A\mathbf{v}_n}{\|A\mathbf{v}_n\|}
\]
The vector \( \mathbf{v}_n \) converges to the eigenvector corresponding to the largest eigenvalue of \( A \).

\section{Ordinary Differential Equations (ODEs)}
\subsection{Initial Value Problems (IVPs)}
An initial value problem for an ODE involves finding a function \( y(t) \) that satisfies the differential equation \( \frac{dy}{dt} = f(t, y) \) with an initial condition \( y(t_0) = y_0 \).

\paragraph{Euler's Method:}
Euler's method is a simple numerical technique for solving IVPs. Starting from \( (t_0, y_0) \), the solution is approximated using:
\[
y_{n+1} = y_n + h f(t_n, y_n)
\]
where \( h \) is the step size.

\paragraph{Runge-Kutta Methods:}
Runge-Kutta methods are a family of iterative methods that provide higher accuracy than Euler's method. The most common is the fourth-order Runge-Kutta (RK4) method, given by:
\[
y_{n+1} = y_n + \frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)
\]
where
\[
k_1 = f(t_n, y_n), \quad k_2 = f\left(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_1\right)
\]
\[
k_3 = f\left(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_2\right), \quad k_4 = f(t_n + h, y_n + h k_3)
\]

\subsection{Boundary Value Problems (BVPs)}
Boundary value problems involve finding a solution to an ODE that satisfies boundary conditions at more than one point. Common methods for solving BVPs include the shooting method and finite difference method.

\paragraph{Shooting Method:}
The shooting method converts a BVP into an IVP. By guessing the initial conditions and integrating the ODE, the solution is adjusted iteratively to satisfy the boundary conditions.

\paragraph{Finite Difference Method:}
The finite difference method discretizes the domain and approximates the differential equation by replacing derivatives with difference equations. The resulting system of algebraic equations is then solved numerically.

\section{Partial Differential Equations (PDEs)}
\subsection{Classification of PDEs}
Partial differential equations are classified into three main types based on their form:

\paragraph{Elliptic PDEs:}
Elliptic PDEs, like the Laplace equation \( \nabla^2 u = 0 \), arise in steady-state problems and describe equilibrium states.

\paragraph{Parabolic PDEs:}
Parabolic PDEs, such as the heat equation \( \frac{\partial u}{\partial t} = \alpha \nabla^2 u \), describe diffusion processes and are used in time-dependent problems.

\paragraph{Hyperbolic PDEs:}
Hyperbolic PDEs, like the wave equation \( \frac{\partial^2 u}{\partial t^2} = c^2 \nabla^2 u \), model wave propagation and other dynamic phenomena.

\subsection{Numerical Methods for PDEs}
Numerical methods for solving PDEsHere is the final version of your LaTeX document with detailed explanations of the mathematical formulas:

```latex
\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\title{Numerical Methods Lecture Notes}
\author{Your Name}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}
Numerical methods are a set of techniques used to solve mathematical problems that are difficult or impossible to solve analytically. These methods are essential in fields such as engineering, physics, computer science, and finance.

\section{Solving Equations}
\subsection{One-Dimensional Case}
In the one-dimensional case, solving an equation \( f(x) = 0 \) involves finding the roots of the function \( f(x) \). Several numerical methods can be used to solve this, including:

\paragraph{Bisection Method:}
The bisection method is a simple iterative algorithm for finding roots of a continuous function. It works by repeatedly bisecting an interval and selecting the subinterval in which the function changes sign. Given an initial interval \([a, b]\) where \( f(a) \) and \( f(b) \) have opposite signs, the method proceeds as:
\[
c = \frac{a + b}{2}
\]
If \( f(c) \) has the opposite sign to \( f(a) \), set \( b = c \); otherwise, set \( a = c \). This process continues until the interval is sufficiently small.

\paragraph{Newton-Raphson Method:}
The Newton-Raphson method is an iterative technique for finding successively better approximations to the roots of a real-valued function. Starting with an initial guess \( x_0 \), the method uses the formula:
\[
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
\]
where \( f'(x_n) \) is the derivative of \( f(x) \) at \( x_n \). The process is repeated until \( |x_{n+1} - x_n| \) is smaller than a predefined tolerance.

\subsection{Multi-Dimensional Case}
In multiple dimensions, solving a system of equations involves finding the roots of a vector-valued function \( \mathbf{F}(\mathbf{x}) = \mathbf{0} \), where \( \mathbf{x} \) is a vector of variables and \( \mathbf{F} \) is a vector of functions. 

\paragraph{Newton's Method for Multidimensional Systems:}
Newton's method can be extended to multiple dimensions. The iterative formula in this case is:
\[
\mathbf{x}_{n+1} = \mathbf{x}_n - \mathbf{J}^{-1}(\mathbf{x}_n) \mathbf{F}(\mathbf{x}_n)
\]
where \( \mathbf{J}(\mathbf{x}_n) \) is the Jacobian matrix of partial derivatives of \( \mathbf{F} \) at \( \mathbf{x}_n \).

\section{Linear Systems of Equations}
\subsection{Gaussian Elimination}
Gaussian elimination is a method for solving linear systems of equations. It systematically reduces the system to upper triangular form using row operations, after which back substitution is used to find the solution. The steps are:

1. Forward elimination to form an upper triangular matrix.
2. Back substitution to solve for the unknowns.

\subsection{LU Decomposition}
LU decomposition is a method of decomposing a matrix \( A \) into a product of a lower triangular matrix \( L \) and an upper triangular matrix \( U \):
\[
A = LU
\]
Once the matrix is decomposed, solving \( A\mathbf{x} = \mathbf{b} \) is reduced to solving two simpler systems: \( L\mathbf{y} = \mathbf{b} \) and \( U\mathbf{x} = \mathbf{y} \).

\subsection{Iterative Methods}
Iterative methods, such as Jacobi and Gauss-Seidel, are used to solve large systems of linear equations where direct methods like Gaussian elimination are computationally expensive. These methods start with an initial guess and iteratively refine the solution.

\paragraph{Jacobi Method:}
In the Jacobi method, each equation is solved for its corresponding variable assuming the other variables are constant. The process is iterated:
\[
x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j \neq i} a_{ij} x_j^{(k)} \right)
\]
where \( a_{ij} \) are the coefficients of the matrix \( A \), and \( b_i \) are the components of the vector \( \mathbf{b} \).

\paragraph{Gauss-Seidel Method:}
The Gauss-Seidel method is an improvement over the Jacobi method, where each variable is updated as soon as its new value is computed:
\[
x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j < i} a_{ij} x_j^{(k+1)} - \sum_{j > i} a_{ij} x_j^{(k)} \right)
\]
This often leads to faster convergence.

\section{Eigenvalues and Eigenvectors}
\subsection{Definition}
For a square matrix \( A \), an eigenvalue \( \lambda \) and corresponding eigenvector \( \mathbf{v} \) satisfy the equation:
\[
A\mathbf{v} = \lambda\mathbf{v}
\]
Eigenvalues and eigenvectors play a crucial role in various applications, including stability analysis, vibrations, and quantum mechanics.

\subsection{Power Method}
The power method is an iterative technique used to find the largest eigenvalue and corresponding eigenvector of a matrix. Starting with an arbitrary vector \( \mathbf{v}_0 \), the method computes:
\[
\mathbf{v}_{n+1} = \frac{A\mathbf{v}_n}{\|A\mathbf{v}_n\|}
\]
The vector \( \mathbf{v}_n \) converges to the eigenvector corresponding to the largest eigenvalue of \( A \).

\section{Ordinary Differential Equations (ODEs)}
\subsection{Initial Value Problems (IVPs)}
An initial value problem for an ODE involves finding a function \( y(t) \) that satisfies the differential equation \( \frac{dy}{dt} = f(t, y) \) with an initial condition \( y(t_0) = y_0 \).

\paragraph{Euler's Method:}
Euler's method is a simple numerical technique for solving IVPs. Starting from \( (t_0, y_0) \), the solution is approximated using:
\[
y_{n+1} = y_n + h f(t_n, y_n)
\]
where \( h \) is the step size.

\paragraph{Runge-Kutta Methods:}
Runge-Kutta methods are a family of iterative methods that provide higher accuracy than Euler's method. The most common is the fourth-order Runge-Kutta (RK4) method, given by:
\[
y_{n+1} = y_n + \frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)
\]
where
\[
k_1 = f(t_n, y_n), \quad k_2 = f\left(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_1\right)
\]
\[
k_3 = f\left(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_2\right), \quad k_4 = f(t_n + h, y_n + h k_3)
\]

\subsection{Boundary Value Problems (BVPs)}
Boundary value problems involve finding a solution to an ODE that satisfies boundary conditions at more than one point. Common methods for solving BVPs include the shooting method and finite difference method.

\paragraph{Shooting Method:}
The shooting method converts a BVP into an IVP. By guessing the initial conditions and integrating the ODE, the solution is adjusted iteratively to satisfy the boundary conditions.

\paragraph{Finite Difference Method:}
The finite difference method discretizes the domain and approximates the differential equation by replacing derivatives with difference equations. The resulting system of algebraic equations is then solved numerically.

\section{Partial Differential Equations (PDEs)}
\subsection{Classification of PDEs}
Partial differential equations are classified into three main types based on their form:

\paragraph{Elliptic PDEs:}
Elliptic PDEs, like the Laplace equation \( \nabla^2 u = 0 \), arise in steady-state problems and describe equilibrium states.

\paragraph{Parabolic PDEs:}
Parabolic PDEs, such as the heat equation \( \frac{\partial u}{\partial t} = \alpha \nabla^2 u \), describe diffusion processes and are used in time-dependent problems.

\paragraph{Hyperbolic PDEs:}
Hyperbolic PDEs, like the wave equation \( \frac{\partial^2 u}{\partial t^2} = c^2 \nabla^2 u \), model wave propagation and other dynamic phenomena.

\subsection{Numerical Methods for PDEs}
Numerical methods for solving PDEs include finite difference methods, finite element methods, and spectral methods.

\paragraph{Finite Difference Methods:}
FiniteIve now expanded the LaTeX document to include detailed explanations for the mathematical formulas in your lecture notes. Below is the full code with added explanations.

```latex
\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\title{Numerical Methods Lecture Notes}
\author{Your Name}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}
Numerical methods are a set of techniques used to solve mathematical problems that are difficult or impossible to solve analytically. These methods are essential in fields such as engineering, physics, computer science, and finance.

\section{Solving Equations}
\subsection{One-Dimensional Case}
In the one-dimensional case, solving an equation \( f(x) = 0 \) involves finding the roots of the function \( f(x) \). Several numerical methods can be used to solve this, including:

\paragraph{Bisection Method:}
The bisection method is a simple iterative algorithm for finding roots of a continuous function. It works by repeatedly bisecting an interval and selecting the subinterval in which the function changes sign. Given an initial interval \([a, b]\) where \( f(a) \) and \( f(b) \) have opposite signs, the method proceeds as:
\[
c = \frac{a + b}{2}
\]
If \( f(c) \) has the opposite sign to \( f(a) \), set \( b = c \); otherwise, set \( a = c \). This process continues until the interval is sufficiently small.

\paragraph{Newton-Raphson Method:}
The Newton-Raphson method is an iterative technique for finding successively better approximations to the roots of a real-valued function. Starting with an initial guess \( x_0 \), the method uses the formula:
\[
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
\]
where \( f'(x_n) \) is the derivative of \( f(x) \) at \( x_n \). The process is repeated until \( |x_{n+1} - x_n| \) is smaller than a predefined tolerance.

\subsection{Multi-Dimensional Case}
In multiple dimensions, solving a system of equations involves finding the roots of a vector-valued function \( \mathbf{F}(\mathbf{x}) = \mathbf{0} \), where \( \mathbf{x} \) is a vector of variables and \( \mathbf{F} \) is a vector of functions. 

\paragraph{Newton's Method for Multidimensional Systems:}
Newton's method can be extended to multiple dimensions. The iterative formula in this case is:
\[
\mathbf{x}_{n+1} = \mathbf{x}_n - \mathbf{J}^{-1}(\mathbf{x}_n) \mathbf{F}(\mathbf{x}_n)
\]
where \( \mathbf{J}(\mathbf{x}_n) \) is the Jacobian matrix of partial derivatives of \( \mathbf{F} \) at \( \mathbf{x}_n \).

\section{Linear Systems of Equations}
\subsection{Gaussian Elimination}
Gaussian elimination is a method for solving linear systems of equations. It systematically reduces the system to upper triangular form using row operations, after which back substitution is used to find the solution. The steps are:

1. Forward elimination to form an upper triangular matrix.
2. Back substitution to solve for the unknowns.

\subsection{LU Decomposition}
LU decomposition is a method of decomposing a matrix \( A \) into a product of a lower triangular matrix \( L \) and an upper triangular matrix \( U \):
\[
A = LU
\]
Once the matrix is decomposed, solving \( A\mathbf{x} = \mathbf{b} \) is reduced to solving two simpler systems: \( L\mathbf{y} = \mathbf{b} \) and \( U\mathbf{x} = \mathbf{y} \).

\subsection{Iterative Methods}
Iterative methods, such as Jacobi and Gauss-Seidel, are used to solve large systems of linear equations where direct methods like Gaussian elimination are computationally expensive. These methods start with an initial guess and iteratively refine the solution.

\paragraph{Jacobi Method:}
In the Jacobi method, each equation is solved for its corresponding variable assuming the other variables are constant. The process is iterated:
\[
x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j \neq i} a_{ij} x_j^{(k)} \right)
\]
where \( a_{ij} \) are the coefficients of the matrix \( A \), and \( b_i \) are the components of the vector \( \mathbf{b} \).

\paragraph{Gauss-Seidel Method:}
The Gauss-Seidel method is an improvement over the Jacobi method, where each variable is updated as soon as its new value is computed:
\[
x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j < i} a_{ij} x_j^{(k+1)} - \sum_{j > i} a_{ij} x_j^{(k)} \right)
\]
This often leads to faster convergence.

\section{Eigenvalues and Eigenvectors}
\subsection{Definition}
For a square matrix \( A \), an eigenvalue \( \lambda \) and corresponding eigenvector \( \mathbf{v} \) satisfy the equation:
\[
A\mathbf{v} = \lambda\mathbf{v}
\]
Eigenvalues and eigenvectors play a crucial role in various applications, including stability analysis, vibrations, and quantum mechanics.

\subsection{Power Method}
The power method is an iterative technique used to find the largest eigenvalue and corresponding eigenvector of a matrix. Starting with an arbitrary vector \( \mathbf{v}_0 \), the method computes:
\[
\mathbf{v}_{n+1} = \frac{A\mathbf{v}_n}{\|A\mathbf{v}_n\|}
\]
The vector \( \mathbf{v}_n \) converges to the eigenvector corresponding to the largest eigenvalue of \( A \).

\section{Ordinary Differential Equations (ODEs)}
\subsection{Initial Value Problems (IVPs)}
An initial value problem for an ODE involves finding a function \( y(t) \) that satisfies the differential equation \( \frac{dy}{dt} = f(t, y) \) with an initial condition \( y(t_0) = y_0 \).

\paragraph{Euler's Method:}
Euler's method is a simple numerical technique for solving IVPs. Starting from \( (t_0, y_0) \), the solution is approximated using:
\[
y_{n+1} = y_n + h f(t_n, y_n)
\]
where \( h \) is the step size.

\paragraph{Runge-Kutta Methods:}
Runge-Kutta methods are a family of iterative methods that provide higher accuracy than Euler's method. The most common is the fourth-order Runge-Kutta (RK4) method, given by:
\[
y_{n+1} = y_n + \frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)
\]
where
\[
k_1 = f(t_n, y_n), \quad k_2 = f\left(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_1\right)
\]
\[
k_3 = f\left(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_2\right), \quad k_4 = f(t_n + h, y_n + h k_3)
\]

\subsection{Boundary Value Problems (BVPs)}
Boundary value problems involve finding a solution to an ODE that satisfies boundary conditions at more than one point. Common methods for solving BVPs include the shooting method and finite difference method.

\paragraph{Shooting Method:}
The shooting method converts a BVP into an IVP. By guessing the initial conditions and integrating the ODE, the solution is adjusted iteratively to satisfy the boundary conditions.

\paragraph{Finite Difference Method:}
The finite difference method discretizes the domain and approximates the differential equation by replacing derivatives with difference equations. The resulting system of algebraic equations is then solved numerically.

\section{Partial Differential Equations (PDEs)}
\subsection{Classification of PDEs}
Partial differential equations are classified into three main types based on their form:

\paragraph{Elliptic PDEs:}
Elliptic PDEs, like the Laplace equation \( \nabla^2 u = 0 \), arise in steady-state problems and describe equilibrium states.

\paragraph{Parabolic PDEs:}
Parabolic PDEs, such as the heat equation \( \frac{\partial u}{\partial t} = \alpha \nabla^2 u \), describe diffusion processes and are used in time-dependent problems.

\paragraph{Hyperbolic PDEs:}
Hyperbolic PDEs, like the wave equation \( \frac{\partial^2 u}{\partial t^2} = c^2 \nabla^2 u \), model wave propagation and other dynamic phenomena.

\subsection{Numerical Methods for PDEs}
Numerical methods for solving PDEs include finite difference methods, finite element methods, and

\end{document}